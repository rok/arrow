from types import ModuleType
from typing import Any, Iterable, TypeGuard  # type: ignore[unresolved_import]

import pandas

from numpy import dtype
from pandas.core.dtypes.base import ExtensionDtype

class _PandasAPIShim:
    has_sparse: bool

    def series(self, *args, **kwargs) -> pandas.Series: ...
    def data_frame(self, *args, **kwargs) -> pandas.DataFrame: ...
    @property
    def have_pandas(self) -> bool: ...
    @property
    def compat(self) -> ModuleType: ...
    @property
    def pd(self) -> ModuleType: ...
    def infer_dtype(self, obj: Iterable) -> str: ...
    def pandas_dtype(self, dtype: str) -> dtype: ...
    @property
    def loose_version(self) -> Any: ...
    @property
    def version(self) -> str: ...
    def is_v1(self) -> bool: ...
    def is_ge_v21(self) -> bool: ...
    def is_ge_v23(self) -> bool: ...
    def is_ge_v3(self) -> bool: ...
    @property
    def categorical_type(self) -> type[pandas.Categorical]: ...
    @property
    def datetimetz_type(self) -> type[pandas.DatetimeTZDtype]: ...
    @property
    def extension_dtype(self) -> type[ExtensionDtype]: ...
    def is_array_like(
        self, obj: Any
    ) -> TypeGuard[pandas.Series | pandas.Index | pandas.Categorical | ExtensionDtype]: ...
    def is_categorical(self, obj: Any) -> TypeGuard[pandas.Categorical]: ...
    def is_datetimetz(self, obj: Any) -> TypeGuard[pandas.DatetimeTZDtype]: ...
    def is_extension_array_dtype(self, obj: Any) -> TypeGuard[ExtensionDtype]: ...
    def is_sparse(self, obj: Any) -> bool: ...
    def is_data_frame(self, obj: Any) -> TypeGuard[pandas.DataFrame]: ...
    def is_series(self, obj: Any) -> TypeGuard[pandas.Series]: ...
    def is_index(self, obj: Any) -> TypeGuard[pandas.Index]: ...
    def get_values(self, obj: Any) -> bool: ...
    def get_rangeindex_attribute(self, level, name): ...

_pandas_api: _PandasAPIShim

__all__ = ["_PandasAPIShim", "_pandas_api"]
